# 変数関連
## インターフェース
```
interface <INTERFACE_NAME> {
	value: int;
	func(): void; 
	// メソッドの追加例
	anotherFunc(param: string): bool;
}
// abstract type
interface <INTERFACE_NAME><<TYPE>> {
}
```

## クラス
```
class <CLASS_NAME> {
	// constructor
	<CLASS_NAME> {
	}
	// メソッド例
	methodExample(param: int): string {
		// 実装例
		return 'Result: ' + param;
	}
}
// abstract type
class <CLASS_NAME><<TYPE>> {
	// constructor
	<CLASS_NAME><<TYPE>> {
	}
	...
}
// implements interface
class <CLASS_NAME> implements <INTERFACE_NAME> {
}
```
クラス継承はナシ。気が向いたら作るけどいったんいらない説を信じていく

## 配列
`<TYPE_NAME>[]`
- 固定長ではない同一型のコレクション。

## タプル
`tuple { <VALUE>... }`
- 異なる型の値を固定長で保持する。

## Record
`Record<<TYPE_A>, <TYPE_B>>`
- キーと値のペアを保持するマップ型。

## 変数宣言
- 変数は`const`または`let`で宣言します。
  - `const`: 再代入不可の変数。
  - `let`: 再代入可能な変数。
- 型指定は`:`を使用します。
  - 例:
    ```
    const x: int = 10;
    let y: float = 3.14;
    y = 2.71; // 再代入可能
    ```

### 暗黙的型定義
- 型指定を省略した場合、初期値に基づいて型が推論されます。
  - 例:
    ```
    const x = 10; // xはint型として推論される
    let y = 3.14; // yはfloat型として推論される
    let z = "hello"; // zはstring型として推論される
    ```
- 初期値がない場合、最初に代入された値に基づいて型が推論されます。
  - 例:
    ```
    let a;
    a = 42; // aはint型として推論される
    ```
- 一度推論された型と異なる型の値を代入することはできません。
  - 例:
    ```
    let b = 10; // bはint型
    b = "text"; // エラー: 型が一致しない
    ```
