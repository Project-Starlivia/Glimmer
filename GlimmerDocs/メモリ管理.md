## ✨ 概要
Glimmerは、Rustのような安全で効率的なメモリ管理をベースに、
TypeScript風の書き味とGC的な使いやすさを併せ持つ設計になっています。

tsに寄せたかったけど、gc書ける気しなかった&rustコンパイル考えたかった

## 🎯 設計方針
ユーザーは基本的にメモリを意識しない（GC風UX）

内部では所有権＋参照カウントで安全に解放

手動管理も可能（パフォーマンス重視時）

Rustへのトランスパイルも視野に入れた構造

## 🧠 メモリ管理の仕組み
### ✅ 自動解放（デフォルト）
変数がスコープを抜けた時、自動で drop() or decRef() が呼ばれます。

所有権は一つ。参照がなくなった時点でオブジェクトは破棄されます。

```ts
let user = new User("taro") // スコープ抜けると自動解放
```
### ✅ 参照カウントによる共有
複数の変数が同じオブジェクトを参照してもOK

すべての参照が切れたときに自動解放

```ts
let a = new Node()
let b = a // 参照カウント +1
```
## 🛠 アノテーションによる制御（上級者向け）
### @owned（デフォルト）
通常の参照管理。スコープで自動解放。

```ts
@owned let buf = new Buffer()
```
### @manual
開発者が free() を呼ぶ必要がある。

パフォーマンスチューニングや永続化用途などに利用。

```ts
@manual let cache = new LargeMap()
```
cache.free()
### @weak
弱参照。参照カウントに含まれない（循環参照防止）

```ts
@weak let ref = node.parent
```
## 🚨 注意点（非GCだからこそ）
循環参照は自動では解放されません

不必要に参照を残すとメモリは解放されません

@manual使用時は必ず明示的に解放する必要があります

## 📌 開発中の補助機能（予定）
🔍 メモリリーク検出モード（開発時のみ）

📉 使用メモリの可視化

🧪 自動テストによるスコープ内のメモリ解放チェック

