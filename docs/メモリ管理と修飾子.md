## ✨ Glimmerのメモリ管理とインスタンス修飾子

Glimmerは、Rustの安全性と効率性をベースに、TypeScript風の書き味とGC的な使いやすさを併せ持つ設計を採用しています。以下では、メモリ管理とインスタンス修飾子について簡潔にまとめます。

---

### 🎯 設計方針
- **ユーザーは基本的にメモリを意識しない**（GC風UX）。
- **所有権＋参照カウント**で安全に解放。
- **手動管理も可能**（パフォーマンス重視時）。
- **Rustへのトランスパイル**も視野に入れた構造。

---

### 🧠 メモリ管理の仕組み
#### ✅ 自動解放（デフォルト）
- スコープを抜けると自動で解放（`drop()` or `decRef()`）。
- 所有権は一つ。参照がなくなるとオブジェクトは破棄。

```ts
{
    let user = new User("taro");
    // スコープを抜けると自動解放
}
```

#### ✅ 参照カウントによる共有
- 複数の変数が同じオブジェクトを参照可能。
- すべての参照が切れたときに自動解放。

```ts
let a = new Node();
let b = a; // 参照カウント +1
```

### 🧠 インスタンス修飾子
#### ✅ 所有構造
- `val`: 値型（データそのものを保持）。
- `ref`: 参照型（データへの参照を保持）。

```ts
val x: int = 10; // 値型
ref y: int = &x; // 参照型
```

#### ✅ 配置先
- `stack`: スタック領域に配置（短期間のデータ向け）。
- `heap`: ヒープ領域に配置（長期間のデータ向け）。

```ts
stack val a: int = 42; // スタックに配置
heap ref b: string = new("hello"); // ヒープに配置
```

### ✅ 寿命管理
寿命管理を指定することで、メモリの破棄タイミングを制御できます。

- `auto`: 自動破棄。スコープを抜けると自動的に破棄されます。
- `manual`: 手動破棄。開発者が明示的に破棄を行います。

```ts
auto stack val temp: float = 3.14; // 自動破棄
manual heap ref obj: MyClass = new(); // 手動破棄
delete(obj); // 明示的に破棄
```

## 🔍 詳細
### 所有構造 (`val`, `ref`)
- **`val`**: 値そのものを保持するため、コピー操作が発生します。  
  例: `val x: int = 10;`
- **`ref`**: データへの参照を保持するため、コピーコストを削減できます。  
  例: `ref y: int = &x;`

### 配置先 (`stack`, `heap`)
- **`stack`**: 高速なメモリアクセスが可能ですが、スコープを抜けると自動的に破棄されます。  
  例: `stack val a: int = 42;`
- **`heap`**: 動的にメモリを確保し、長期間保持できますが、管理コストが高くなります。  
  例: `heap ref b: string = new("hello");`

### 寿命管理 (`auto`, `manual`)
- **`auto`**: メモリ管理をコンパイラに任せることで、安全性を向上します。  
  例: `auto stack val temp: float = 3.14;`
- **`manual`**: 開発者が破棄タイミングを制御することで、柔軟性を確保します。  
  例: `manual heap ref obj: MyClass = new();`

## 🚀 応用
### 組み合わせの例
アクセス修飾子を組み合わせることで、柔軟なメモリ管理が可能です。

```ts
auto stack val counter: int = 0; // スタックに配置され、自動破棄
manual heap ref data: MyClass = new(); // ヒープに配置され、手動破棄
delete(data); // 明示的に破棄
```

### 高度な使用例
関数の引数や戻り値にもアクセス修飾子を適用できます。

```ts
function processData(auto stack val input: int): auto heap ref string {
    return new("Processed: " + input);
}
```

このように、Glimmerのアクセス修飾子を活用することで、効率的かつ安全なメモリ管理が実現できます。